<?php

namespace <%= servicesNamespace %>\Channels;

<% for (let usedClass of usedClasses) { -%>
use <%= modelsNamespace %>\<%= usedClass %>;
<% } -%>

use AsyncAPI\Services\MessageBroker\Client;
use AsyncAPI\Services\MessageBroker\Destination;
use AsyncAPI\Services\MessageBroker\Message;

use JMS\Serializer\Serializer;
use JMS\Serializer\SerializerBuilder;
use RuntimeException;
use Rx\Observable;
use Rx\Subject\Subject;

class <%= channelClassNamePrefix %>Channel
{

    <% if (subscribeOperation) { %>
    private const DISCRIMINATOR_PROPERTY_NAME = '<%= subscribeOperation.payload.discriminator %>';
    <% } -%>

    private const MODELS_NAMESPACE = '<%= modelsNamespace %>';

    private const DESTINATION_NAME = '<%= channelName %>';

    private Client $client;
    private Destination $destination;
    private Serializer $serializer;

    <% if (subscribeOperation) { %>
    private Subject $<%= lowerCaseFirst(subscribeOperation.payload.name) %>Subject;
    <% for( let index = 0; index < subscribeOperation.payload.subClasses.length; index++ ) { %>
    private Subject $<%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %>Subject;
    public readonly Observable $<%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %>;
    <% } -%>
    <% } -%>

    public function __construct(Client $client)
    {

        if (!$client->isConnected()) {
            throw new RuntimeException('The message broker client must already be connected.');
        }

        $this->client = $client;

        $this->destination = new Destination(self::DESTINATION_NAME);

        $this->serializer = SerializerBuilder::create()->build();

        <% if (subscribeOperation) { %>
        $this-><%= lowerCaseFirst(subscribeOperation.payload.name) %>Subject = new Subject();
        <% for( let index = 0; index < subscribeOperation.payload.subClasses.length; index++ ) { %>
        $this-><%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %>Subject = new Subject();
        $this-><%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %> = $this-><%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %>Subject->asObservable();
        <% } -%>
        <% } -%>

    }

    <% if (publishOperation) { %>
    public function <%= publishOperation.name %>(<%= publishOperation.payload.name %> $<%= lowerCaseFirst(publishOperation.payload.name) %>): void
    {
        $message = $this->buildMessageWithObject($<%= lowerCaseFirst(publishOperation.payload.name) %>);

        $this->client->publish($message, $this->destination);
    }
    <% } -%>

    <% if (subscribeOperation) { %>
    public function <%= subscribeOperation.name %>(): Observable
    {
        return $this-><%= lowerCaseFirst(subscribeOperation.payload.name) %>Subject->asObservable();
    }
    <% } -%>

    public function listen(): void
    {
        $this->client->subscribe($this->destination, function (Message $message) {
            $object = $this->extractObjectFromMessage($message);

            $this-><%= lowerCaseFirst(subscribeOperation.payload.name) %>Subject->onNext($object);
            
            $objectFullyQualifiedClassName = get_class($object);
            switch ($objectFullyQualifiedClassName) {
                <% for( let index = 0; index < subscribeOperation.payload.subClasses.length; index++ ) { %>
                case <%= subscribeOperation.payload.subClasses[index].name %>::class:
                    $this-><%= lowerCaseFirst(subscribeOperation.payload.subClasses[index].name) %>Subject->onNext($object);
                    break;
                <% } %>
                default:
                    throw new RuntimeException("Unhandled object class '$objectFullyQualifiedClassName'.");
            }
        });
    }

    private function buildMessageWithObject(object $object): Message
    {
        $jsonContent = $this->serializer->serialize($object, 'json');

        $message = new Message('', $jsonContent);

        return $message;
    }

    private function extractObjectFromMessage(Message $message): <%= subscribeOperation.payload.name %>
    {
        $body = $message->getBody();

        $data = json_decode($body, true);

        if ($data == null) {
            throw new RuntimeException('The message body does not contain a valid JSON.');
        }

        $discriminatorPropertyName = self::DISCRIMINATOR_PROPERTY_NAME;

        if (!array_key_exists($discriminatorPropertyName, $data)) {
            throw new RuntimeException("The JSON object representation does not contain the '$discriminatorPropertyName' discriminator property.");
        }

        $discriminatorPropertyValue = $data[$discriminatorPropertyName];

        if (empty($discriminatorPropertyValue)) {
            throw new RuntimeException("The JSON object '$discriminatorPropertyName' discriminator property is empty.");
        }

        $type = $this->getFullyQualifiedClassName($discriminatorPropertyValue);

        $object = $this->serializer->deserialize($body, $type, 'json');

        return $object;
    }

    private function getFullyQualifiedClassName($className): string
    {
        return self::MODELS_NAMESPACE . '\\' . $className;
    }

}